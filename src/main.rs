mod utils;

use clap::{crate_name, crate_version, Parser};
use colored::Colorize;
use std::{fs::File, io::prelude::*, path::Path};
use translator_lib::{generate_code, parse_lines, TranslatorError};
use utils::{file_into_lines, file_name_from_path};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    target: String,

    #[arg(short, long)]
    /// Output file path. (Defaults to `<TARGET>.asm`, if not specified.)
    output: Option<String>,

    #[arg(short = 'O', long, action)]
    /// Toggles optimizations to the generated assembly code.
    optimize: bool,

    #[arg(long, action)]
    /// Sets log level to DEBUG
    log_debug: bool,
}

fn main() {
    let args = Args::parse();

    // ========== checks if is debug mode ==========
    let is_debug_mode = cfg!(debug_assertions) || args.log_debug;
    if is_debug_mode {
        simple_logger::init_with_level(log::Level::Debug).unwrap();
    }
    log::debug!("Debug mode is {}", is_debug_mode);

    // ========== read file into memory ==========
    let target_path = Path::new(&args.target);
    log::debug!("target_path = {:?}", target_path);
    if !target_path.exists() {
        eprintln!(
            "{}",
            TranslatorError::FileIOError {
                message: format!("Target file path `{}` does not exist", args.target),
            }
        );
        return;
    }
    let target_file_name: String = file_name_from_path(target_path);
    log::debug!("target_file_name = {}", &target_file_name);

    let target_result = File::open(target_path);
    log::debug!("target_result = {:?}", target_result);
    if target_result.is_err() {
        eprintln!("{}", TranslatorError::from(target_result.unwrap_err()));
        return;
    }
    let target = target_result.unwrap();

    // ========== parse file into lines ==========
    let unprocessed_lines: Vec<String> = file_into_lines(target);

    // ========== parse input into tokens ==========
    let parsed_lines_result = parse_lines(unprocessed_lines);
    if parsed_lines_result.is_err() {
        eprintln!("{}", parsed_lines_result.unwrap_err());
        return;
    }
    let parsed_lines = parsed_lines_result.unwrap();
    log::debug!("Parsed lines length is {}", parsed_lines.len());

    // ========== generate code ==========
    let generation_result = generate_code(parsed_lines, &target_file_name, args.optimize);
    if generation_result.is_err() {
        eprintln!("{}", generation_result.unwrap_err());
        return;
    }
    let generated_code = generation_result.unwrap();
    log::debug!("Generated Code segments is {}", generated_code.len());

    // ========== save generated code to output file
    let output_file_name = if args.output.is_none() {
        format!("{}.asm", target_file_name)
    } else {
        args.output.unwrap()
    };
    log::debug!("Output file path: {}", output_file_name);
    let output_file_create = File::create(&output_file_name);
    if output_file_create.is_err() {
        eprintln!("{}", TranslatorError::from(output_file_create.unwrap_err()));
        return;
    }
    let mut output_file = output_file_create.unwrap();

    let output_file_header = format!(
        "// Translation of \"{}\"\n// Generated by {} ({})",
        args.target,
        crate_name!(),
        crate_version!()
    );
    output_file
        .write_all(output_file_header.as_bytes())
        .unwrap();

    for translated_line in generated_code {
        output_file.write_all(translated_line.as_bytes()).unwrap();

        if !args.optimize {
            output_file.write_all("\n\n".as_bytes()).unwrap();
        }
    }
    if is_debug_mode {
        log::debug!(
            "Output file size is {} bytes",
            output_file.metadata().unwrap().len()
        );
    }

    print!(
        "{} {} {}",
        "Created".bold().green(),
        output_file_name.underline(),
        "successfully".bold().green()
    );

    if args.optimize {
        println!(" {}", "(Optimized)".bright_cyan());
    } else {
        println!();
    }
}
