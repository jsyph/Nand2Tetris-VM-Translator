mod utils;

use clap::{crate_name, crate_version, Parser};
use colored::Colorize;
use std::{
    fs::{self, File},
    io::prelude::*,
    path::Path,
};
use translator_lib::{generate_code, parse_lines, TranslatorError};
use utils::{file_into_lines, name_from_path};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Input file or directory
    target: String,

    #[arg(short, long)]
    /// Output file path. (Defaults to `<TARGET>.asm`, if not specified.)
    output: Option<String>,

    #[arg(short = 'O', long, action)]
    /// Toggles optimizations to the generated assembly code.
    optimize: bool,

    #[arg(long, action)]
    /// Sets log level to DEBUG
    log_debug: bool,
}

fn main() {
    let args = Args::parse();

    // ========== checks if is debug mode ==========
    let is_debug_mode = cfg!(debug_assertions) || args.log_debug;
    if is_debug_mode {
        simple_logger::init_with_level(log::Level::Debug).unwrap();
    }
    log::debug!("Debug mode is {}", is_debug_mode);

    // ========== read file into memory ==========
    let target_path = Path::new(&args.target);
    log::debug!("target_path = {:?}", target_path);
    if !target_path.exists() {
        eprintln!(
            "{}",
            TranslatorError::FileIOError {
                message: format!("Target path `{}` does not exist", args.target),
            }
        );
        return;
    }
    let target_name: String = name_from_path(target_path);
    log::debug!("target_name = {}", &target_name);

    // if file is target, then parse into vector
    // if is directory, loop over .vm files and combine into vector

    let mut unprocessed_lines: Vec<String> = Vec::new();
    if target_path.is_file() {
        let target_result = File::open(target_path);
        log::debug!("target_result = {:?}", target_result);
        if target_result.is_err() {
            eprintln!("{}", TranslatorError::from(target_result.unwrap_err()));
            return;
        }
        let target = target_result.unwrap();

        // ========== parse file into lines ==========
        unprocessed_lines = file_into_lines(target);
    } else {
        for file in fs::read_dir(target_path).expect("Unable to read directory") {
            let path = file.expect("Unable to get file entry").path();
            log::debug!("{:?}: path = {:?}", target_path, path);

            if path.extension().unwrap() != "vm" {
                log::debug!("Skipped processing {}", path.to_str().unwrap());
                continue;
            }

            let target_result = File::open(path);
            log::debug!("target_result = {:?}", target_result);
            if target_result.is_err() {
                eprintln!("{}", TranslatorError::from(target_result.unwrap_err()));
                return;
            }
            let target = target_result.unwrap();

            // ========== parse file into lines ==========
            let lines = file_into_lines(target);
            for line in lines {
                unprocessed_lines.push(line);
            }
        }
    }
    log::debug!("Unprocessed lines length is {}", unprocessed_lines.len());

    // ========== parse input into tokens ==========
    let parsed_lines_result = parse_lines(unprocessed_lines);
    if parsed_lines_result.is_err() {
        eprintln!("{}", parsed_lines_result.unwrap_err());
        return;
    }
    let parsed_lines = parsed_lines_result.unwrap();
    log::debug!("Parsed lines length is {}", parsed_lines.len());

    // ========== generate code ==========
    let generation_result = generate_code(
        parsed_lines,
        &target_name,
        args.optimize,
        target_path.is_dir(),// generate bootstrap if target is directory
    );
    if generation_result.is_err() {
        eprintln!("{}", generation_result.unwrap_err());
        return;
    }
    let generated_code = generation_result.unwrap();
    log::debug!("Generated Code segments is {}", generated_code.len());

    // ========== save generated code to output file
    let output_file_name = if args.output.is_none() {
        format!("{}.asm", target_name)
    } else {
        args.output.unwrap()
    };
    log::debug!("Output file path: {}", output_file_name);
    let output_file_create = File::create(&output_file_name);
    if output_file_create.is_err() {
        eprintln!("{}", TranslatorError::from(output_file_create.unwrap_err()));
        return;
    }
    let mut output_file = output_file_create.unwrap();

    let output_file_header = format!(
        "// Translation of \"{}\"\n// Generated by {} ({})",
        args.target,
        crate_name!(),
        crate_version!()
    );
    output_file
        .write_all(output_file_header.as_bytes())
        .unwrap();
    if !args.optimize {
        output_file.write_all("\n".as_bytes()).unwrap();
    }

    for translated_line in generated_code {
        output_file.write_all(translated_line.as_bytes()).unwrap();

        if !args.optimize {
            output_file.write_all("\n\n".as_bytes()).unwrap();
        }
    }
    if is_debug_mode {
        log::debug!(
            "Output file size is {} bytes",
            output_file.metadata().unwrap().len()
        );
    }

    print!(
        "{} {} {}",
        "Created".bold().green(),
        output_file_name.underline(),
        "successfully".bold().green()
    );

    if args.optimize {
        println!(" {}", "(Optimized)".bright_cyan());
    } else {
        println!();
    }
}
